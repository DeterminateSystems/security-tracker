#!/usr/bin/env python
from app.pacman import update as update_pacman_db, search, get_configpath, archs, primary_arch
from app import db
from app.model import CVEGroup, CVEGroupPackage, CVE, CVEGroupEntry, Package
from app.model.enum import Status, Affected, affected_to_status, status_to_affected, highest_severity
from sqlalchemy import func
from collections import defaultdict
from argparse import ArgumentParser
from sys import argv
from subprocess import check_output


def update_group_status():
    groups = (db.session.query(CVEGroup, func.group_concat(CVEGroupPackage.pkgname, ' '))
              .join(CVEGroupPackage)
              .filter(CVEGroup.status.in_([Status.vulnerable, Status.testing]))
              .group_by(CVEGroupPackage.group_id)).all()
    for group, pkgnames in groups:
        pkgnames = pkgnames.split(' ')
        group.status = affected_to_status(status_to_affected(group.status), pkgnames[0], group.fixed)
    db.session.commit()


def recalc_group_status():
    groups = (db.session.query(CVEGroup, func.group_concat(CVEGroupPackage.pkgname, ' '))
              .join(CVEGroupPackage)
              .group_by(CVEGroupPackage.group_id)).all()
    for group, pkgnames in groups:
        pkgnames = pkgnames.split(' ')
        group.status = affected_to_status(status_to_affected(group.status), pkgnames[0], group.fixed)
    db.session.commit()


def recalc_group_severity():
    entries = (db.session.query(CVEGroup, CVEGroupEntry, CVE)
               .join(CVEGroupEntry).join(CVE)
               .group_by(CVEGroupEntry.group_id).group_by(CVE.id)).all()
    issues = defaultdict(set)
    for group, entry, issue in entries:
        issues[group].add(issue)
    for group, issues in issues.items():
        group.severity = highest_severity([issue.severity for issue in issues])
    db.session.commit()


def update_package_cache():
    print('    --> Querying alpm database...')
    packages = search('', filter_duplicate_packages=False, sort_results=False)

    pkgbases = {}
    packages_by_arch = defaultdict(list)
    packages_by_name_db_arch = {}
    packages_by_name = defaultdict(list)

    # assign packages per arch list (unify any into 64bit)
    for package in packages:
        arch = package.arch if package.arch != 'any' else primary_arch
        if package.name not in packages_by_arch[arch]:
            packages_by_arch[arch].append(package.name)
        packages_by_name_db_arch['{}_{}_{}'.format(
            package.name, package.db.name, package.arch)] = package
        packages_by_name[package.name].append(package)

    print('    --> Collecting pkgbases...')
    # query all pkgbases per arch
    for arch in archs:
        cmd = ['expac', '-S', '--config', get_configpath(arch), '%n %e']
        cmd.extend(packages_by_arch[arch])
        bases = check_output(cmd).decode().split('\n')[:-1]
        for base in bases:
            pkgname, pkgbase = (base.split(' '))
            pkgbases[pkgname] = pkgbase if pkgbase != '(null)' else pkgname

    # build up different lookup dicts for fast fetching of incremental changes
    db_packages = Package.query.all()
    db.session.commit()
    db_packages_obsolete = [pkg.name for pkg in db_packages if pkg.name not in packages_by_name]
    db_packages = [pkg for pkg in db_packages if pkg.name not in db_packages_obsolete]
    db_packages_by_name_db_arch = {}
    for package in db_packages:
        db_packages_by_name_db_arch['{}_{}_{}'.format(
               package.name, package.database, package.arch)] = package

    print('    --> Deleting obsolete packages...')
    if len(db_packages_obsolete) > 0:
        Package.query.filter(Package.name.in_(db_packages_obsolete)).all()
        db.session.commit()

    print('    --> Deleting obsolete variants...')
    for key, db_package in db_packages_by_name_db_arch.items():
        # delete if the database and arch variant does not exist anymore
        if key not in packages_by_name_db_arch:
            db.session.delete(db_package)
    db.session.commit()

    print('    --> Updating package variants...')
    for key, package in packages_by_name_db_arch.items():
        new_package = False
        # old database and arch variant exists, use it to update the lines
        if key in db_packages_by_name_db_arch:
            db_package = db_packages_by_name_db_arch[key]
            # skip entry if it has the same version as the database entry
            if db_package.version == package.version:
                continue
        # database and arch variant is new, insert it as new entry
        else:
            db_package = Package()
            new_package = True

        # assign database properties
        db_package.name = package.name
        db_package.base = pkgbases[package.name]
        db_package.version = package.version
        db_package.description = package.desc
        db_package.url = package.url
        db_package.arch = package.arch
        db_package.database = package.db.name
        db_package.filename = package.filename
        db_package.md5sum = package.md5sum
        db_package.sha256sum = package.sha256sum
        db_package.builddate = package.builddate

        if new_package:
            db.session.add(db_package)
        db.session.commit()

def db_vacuum():
    db.session.execute('VACUUM')


if __name__ == "__main__":
    no_args = 1 >= len(argv)
    parser = ArgumentParser(prog='update')
    parser.add_argument('--pacman-db', action='store_true', default=no_args)
    parser.add_argument('--group-status', action='store_true', default=no_args)
    parser.add_argument('--recalc-group-status', action='store_true')
    parser.add_argument('--recalc-group-severity', action='store_true')
    parser.add_argument('--package-cache', action='store_true', default=no_args)
    parser.add_argument('--db-vacuum', action='store_true')
    args = parser.parse_args()

    if args.pacman_db:
        print("[+] Update pacman db...")
        update_pacman_db(force=True)

    if args.package_cache:
        print("[+] Update package cache...")
        update_package_cache()

    if args.group_status:
        print("[+] Update group status...")
        update_group_status()

    if args.recalc_group_status:
        print("[+] Recalc group status...")
        recalc_group_status()

    if args.recalc_group_severity:
        print("[+] Recalc group severity...")
        recalc_group_severity()

    if args.db_vacuum:
        print("[+] Compact database...")
        db_vacuum()
